--delot za latex
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{esint}
\begin{document}
\title{ТЕОРИЈА:}
За да филтрираме слика во фреквенциски домен потребно е да ја помножиме
сликата во фреквенциски домен со филтерот (кернел) кој е исто така во
фреквенциски домен.
\begin{equation}
I_{f,filt}=HI_f
\end{equation}
За таа цел потребно е да се вметне Octave функција која ќе креира “Band pass
gaussian filter” во фреквенциски домен. Bandpass гаусовиот филтер во
фреквенциски домен е дефиниран со равенката:
\begin{equation}
H_{(i,j)}=e^{-\frac{d(i,j)^2}{f_h^2}}(1-e^{-\frac{d(i,j)^2}{f_l^2}})
\end{equation}

Каде што $d(i,j)$ е евклидовото растојанието на даден пиксел од центарот на
сликата, додека $f_h$ и $f_l$ се праговите на високите и ниските фреквенции кои сакаме
да ги филтрираме.
Конверзија на 2D сликата од просторен во фреквенциски домен се прави со
користење на Фуриева трансформација. Фуриевата трансформација е дефинирана
како:

         $F(u,v)=\iint \limits_{-\infty}^{\infty} f(x,y)e^{-i2\pi(ux+vy)}dxdy$


А во дискретниот домен горната равенка може да биде преведена како
\begin{equation}
F(u,v)=\sum_{m=-\infty}^{\infty}\sum_{n=-\infty}^{\infty}f[m,n]\cdot e^{-i2\pi(xmu_0+ynv_0)}
\end{equation}
Конверзија на 2D сликата од фреквенциски во просторен домен се прави со
користење на инверзна Фуриева трансформација. Инверзната Фуриева
трансформација е дефинирана како:

$f(x,y)=\iint \limits_{-\infty}^{\infty}F(u,v)e^{i2\pi(ux+vy)}dudv$

А во дискретниот домен горната равенка може да биде преведена како
\begin{equation}
f(x,y)=\sum_{m=-\infty}^{\infty}\sum_{n=-\infty}^{\infty}F(m,n)\cdot e^{i2\pi(xmu_0+ynv_0)}
\end{equation}
\end{document}

--prikaz na slikite

%%file create_filter.m
function filter = create_filter(nx,ny,d0,d1)

filter = ones(nx,ny);

for i = 0:nx-1,
            for j = 0:ny-1
                 dist= sqrt((i-nx/2)^2 + (j-ny/2)^2);
                 filter(i+1,j+1) = exp(-dist^2/(2*(d1^2))).*(1.0-exp(-dist^2/(2*(d0^2))));
            end
end

filter(nx/2+1,ny/2+1)=1;
end

%store data
clear all
%read image
im = double(imread('C:/Users/mlade/Desktop/ice.jpg'));
%size of the image
[nx ny] = size(im);
%Transform the image from spatial to frequency domain
im_fft = fftshift(fft2(im));
% Create Gaussian bandpass kernels, in frequency domain, for 20 different cut off frequencies and filter the image
p=1;
for i = 1:10:21
q=1;
    for j = 1:10:21
        %Create the bandpass kernel
        tmp1 = create_filter(nx,ny,i,j);
        %Filter the image with the bandpass kernel and transform it back to spatial domain
        tmp = (abs(ifft2(ifftshift(tmp1.*im_fft))));
        %Save the filtered image (in spatial domain) and kernel (in frequency domain) for visualization 
        filtered_image(p,q,:) = tmp(:);
        filter_kernel(p,q,:) = tmp1(:);
        q=q+1;
    end
    
    p=p+1;
end
save filtered_image
save filter_kernel
imshow(tmp)
imshow(tmp1)

%matplotlib nbagg

import ipywidgets as widgets
from IPython.display import display
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.image as mpimg
import scipy.io as sio

value = widgets.IntRangeSlider(
    value=[0, 10],
    min=0,
    max=10,
    step=1,,
    disabled=False,
    continuous_update=False,
    orientation='horizontal',
    readout=True,
    readout_format='d',
    layout={'width': '100%'}
)

def slika(vrednost_1, vrednost_2):
    filtered_image = sio.loadmat('filtered_image.mat')
    f_images = filtered_image['filtered_image']
    temp = f_images[value_0][value_1][0:]
    temp = temp.reshape(402,566)
    temp = np.rot90(temp, -1)
    return temp;
    
def prikazigokernelot(vrednost_1,vrednost_2):
    filtered_kernel = sio.loadmat('filter_kernel.mat')
    f_kernels = filtered_kernel['filter_kernel']
    temp = f_kernels[vrednost_1][vrednost_2][0:]
    temp = temp.reshape(402,566)
    temp = np.rot90(temp, -1)
    return temp;

def update_plot(value):
    value_0 = value[0]
    value_1 = value[1]
    image = slika(value_0, value_1)
    kernel = prikazigokernelot(value_0, value_1)
    slika1 = (image)
    slika2 = (kernel)
    slika1=np.fliplr(slika1)
    slika2=np.fliplr(slika2)
    plot_image = np.concatenate((slika1, slika2), axis=1)
    plt.imshow(plot_image, cmap="gray")
    plt.title('Filtrirana slika')
    plt.axis('off')
    plt.show()

widgets.interactive(update_plot, value=value)

